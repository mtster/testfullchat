<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>App Debug — Protocol Chat</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:0; background:#0b0f14; color:#e6eef8; }
    header { padding:12px; background:#071022; border-bottom:1px solid rgba(255,255,255,0.03); }
    h1 { margin:0; font-size:16px; font-weight:600; }
    .main { display:flex; gap:12px; padding:12px; }
    .left { flex:1; min-width:320px; }
    .panel { background:#0f1720; border:1px solid rgba(255,255,255,0.03); padding:12px; border-radius:8px; margin-bottom:12px; }
    pre { white-space:pre-wrap; word-break:break-word; background:rgba(255,255,255,0.02); padding:8px; border-radius:6px; font-size:13px; }
    iframe { width:100%; height:640px; border:1px solid rgba(255,255,255,0.04); border-radius:8px; display:block; background:white; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .pill { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:999px; font-size:13px; }
    .muted { color:#9fb0c3; font-size:13px; }
    button { background:#0b84ff; color:white; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; }
  </style>
</head>
<body>
  <header>
    <h1>Protocol Chat — Diagnostic page (v2)</h1>
    <div style="font-size:13px; color:#9fb0c3; margin-top:6px;">Will fetch your site root and service worker, show headers and final URL, and then attempt to load the app into the iframe.</div>
  </header>

  <div style="padding:12px;">
    <div class="panel">
      <div class="row"><div class="pill">Site fetch & headers</div></div>
      <div id="fetchResult"><pre>waiting...</pre></div>
      <div style="margin-top:8px;">
        <button id="doFetch">Run fetch check & load iframe</button>
      </div>
    </div>

    <div class="panel">
      <div class="row"><div class="pill">Service worker check</div></div>
      <div id="swResult"><pre>waiting...</pre></div>
    </div>

    <div class="panel">
      <div class="row"><div class="pill">Iframe / App</div></div>
      <div id="frameWrap">
        <iframe id="appFrame" src="about:blank" title="App iframe"></iframe>
      </div>
      <div style="margin-top:8px;">
        <button id="reloadFrame">Reload iframe</button>
        <button id="clearFrameLS">Clear iframe localStorage</button>
      </div>
      <div style="margin-top:10px;"><small class="muted">If the iframe fails to load, the fetch results above will show why (redirect URL, headers).</small></div>
    </div>

    <div class="panel">
      <div class="row"><div class="pill">Captured errors & promise rejections</div></div>
      <div id="errors"><pre>(none yet)</pre></div>
    </div>

    <div class="panel">
      <div class="row"><div class="pill">Notifications & FCM quick status</div></div>
      <div id="notifs"><pre>waiting for iframe...</pre></div>
    </div>

    <div style="margin-top:12px;" class="panel">
      <div style="font-size:13px;" class="muted">
        Steps: Tap "Run fetch check & load iframe". After the iframe appears, login and use the app. Then paste here the <b>fetch result</b>, <b>service worker check</b>, <b>errors</b> and <b>Notifications & FCM</b> panels.
      </div>
    </div>
  </div>

<script>
(async function(){
  // compute base path (repo path), e.g. /testfullchat (we are in that folder)
  const basePath = (function(){
    const p = location.pathname.replace(/\\/debug.html$/, '').replace(/\\/$/, '');
    return p || '';
  })();

  const appUrl = location.origin + (basePath ? basePath + '/' : '/');
  const swUrl = location.origin + (basePath ? basePath + '/firebase-messaging-sw.js' : '/firebase-messaging-sw.js');
  const fetchEl = document.getElementById('fetchResult');
  const swEl = document.getElementById('swResult');
  const iframe = document.getElementById('appFrame');
  const errorsEl = document.getElementById('errors');
  const notifsEl = document.getElementById('notifs');
  const doFetchBtn = document.getElementById('doFetch');
  const reloadFrameBtn = document.getElementById('reloadFrame');
  const clearLSBtn = document.getElementById('clearFrameLS');

  function show(el, text) { el.innerHTML = '<pre>' + (text || '') + '</pre>'; }

  async function runChecks() {
    show(fetchEl, 'fetching ' + appUrl + ' ...');
    try {
      const r = await fetch(appUrl, { cache: 'no-cache', redirect: 'follow' });
      const ct = r.headers.get('content-type') || '';
      const xfo = r.headers.get('x-frame-options') || '(none)';
      const csp = r.headers.get('content-security-policy') || '(none)';
      const fa = r.headers.get('feature-policy') || r.headers.get('permissions-policy') || '(none)';
      const finalURL = r.url || '(none)';
      const status = r.status;
      const text = await r.text().then(t => t.slice(0, 2000)).catch(()=>'(no body)');
      show(fetchEl, [
        'Fetch OK. status: ' + status,
        'Final URL: ' + finalURL,
        'Content-Type: ' + ct,
        'X-Frame-Options: ' + xfo,
        'Content-Security-Policy: ' + csp,
        'Feature/Permissions-Policy: ' + fa,
        '',
        'First 2000 chars of response body (for inspection):',
        '-------------------------------------------------',
        text
      ].join('\\n'));
      // service worker check
      try {
        const rsw = await fetch(swUrl, { cache:'no-cache' });
        const sct = rsw.headers.get('content-type') || '';
        show(swEl, `SW fetch status: ${rsw.status}\\nSW final URL: ${rsw.url}\\nSW content-type: ${sct}`);
      } catch (err) {
        show(swEl, 'SW fetch failed: ' + (err && err.message));
      }

      // If finalURL looks okay (same as appUrl or same origin), try to load iframe.
      // But if finalURL ends with firebase-messaging-sw.js or content-type is javascript or not html, still load iframe to confirm behavior.
      iframe.src = appUrl;
      iframe.onload = () => {
        show(errorsEl, '(no errors yet)');
        show(notifsEl, 'iframe loaded. Interact with app (login, open chat). This panel will poll for Notification.permission and localStorage.user every 2s.');
        attachIframeListeners();
      };
      iframe.onerror = (ev) => {
        show(errorsEl, 'iframe failed to load (error event). You may have frame-ancestors or X-Frame-Options blocking embedding.');
      };
    } catch (err) {
      show(fetchEl, 'Fetch failed: ' + (err && err.message));
    }
  }

  async function attachIframeListeners() {
    try {
      const w = iframe.contentWindow;
      // capture errors & rejections
      w.addEventListener('error', function(ev){
        const msg = [
          'Message: ' + (ev && ev.message),
          'Source: ' + (ev && ev.filename) + ':' + (ev && ev.lineno) + ':' + (ev && ev.colno),
          'Error object: ' + (ev && ev.error && ev.error.stack ? ev.error.stack : JSON.stringify(ev.error || 'no stack'))
        ].join('\\n');
        show(errorsEl, msg);
      });
      w.addEventListener('unhandledrejection', function(ev){
        let reason = ev && ev.reason;
        let text = 'UnhandledRejection: ';
        if (!reason) text += '(no reason)';
        else if (reason.stack) text += reason.stack;
        else if (typeof reason === 'object') text += JSON.stringify(reason);
        else text += String(reason);
        show(errorsEl, text);
      });

      // poll Notification.permission and localStorage.user and fcmTokens existence
      const dbOrigin = 'https://protocol-chat-b6120-default-rtdb.europe-west1.firebasedatabase.app';
      const poll = setInterval(async () => {
        try {
          let perm = 'n/a';
          try { perm = w.Notification && w.Notification.permission ? w.Notification.permission : 'n/a'; } catch(e){ perm = 'error'; }
          let user = null;
          try {
            const raw = w.localStorage.getItem('user');
            user = raw ? JSON.parse(raw) : null;
          } catch(e) { user = null; }
          let tokenLine = 'no logged user found in localStorage';
          if (user && user.id) {
            try {
              const tokenUrl = dbOrigin + '/fcmTokens/' + encodeURIComponent(user.id) + '.json';
              const r = await fetch(tokenUrl, { cache:'no-cache' });
              if (r.ok) {
                const j = await r.json();
                tokenLine = 'fcmTokens/' + user.id + ': ' + (j ? JSON.stringify(j) : '(no tokens)');
              } else {
                tokenLine = 'fcmTokens fetch status ' + r.status;
              }
            } catch (err) {
              tokenLine = 'fcmTokens fetch failed: ' + (err && err.message);
            }
          }
          show(notifsEl, 'Notification.permission (in iframe): ' + perm + '\\nlocalStorage.user: ' + (user ? JSON.stringify(user) : '(null)') + '\\n' + tokenLine);
        } catch (err) {
          show(notifsEl, 'Polling error: ' + (err && err.message));
        }
      }, 2000);

      iframe._poller = poll;
    } catch (err) {
      show(errorsEl, 'attachIframeListeners failed: ' + (err && err.message));
    }
  }

  doFetchBtn.addEventListener('click', runChecks);
  reloadFrameBtn.addEventListener('click', () => {
    try {
      if (iframe._poller) clearInterval(iframe._poller);
    } catch(_) {}
    iframe.contentWindow.location.reload();
  });
  clearLSBtn.addEventListener('click', () => {
    try {
      iframe.contentWindow.localStorage.clear();
      show(notifsEl, 'Cleared iframe localStorage. Reload iframe and login again.');
    } catch (err) {
      show(errorsEl, 'clear iframe localStorage failed: ' + (err && err.message));
    }
  });

  // auto-run on open
  // setTimeout(runChecks, 150);
})();
</script>
</body>
</html>
